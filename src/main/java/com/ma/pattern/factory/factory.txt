
依赖倒置原则:?依赖抽象,不能依赖具体的类.[工厂方法遵循这个原则]
    不能让高层组(high-level module)件依赖低层组件??
        当应用这个原则时，它意味着高级类不能直接使用低级类，它们使用接口作为抽象层。
        在这种情况下，不能在高级类（如果需要）内实例化新的低级对象。
        相反，可以使用一些Creational设计模式，例如Factory Method，Abstract Factory，Prototype。
    违反依赖倒置原则的编码:(足够的理由可以打破)
        1.变量不可以持有具体类的引用
        2.不要让类派生自具体的类
        3.不要覆盖已实现的方法


工厂模式都是用于封装对象的创建 :
简单工厂模式: 一种变成习惯,不是真正的设计模式.
               只有一个工厂类, 实例化的对象的时候,传递指定对象的类型(Class clazz),[参数化工厂方法]
               工厂类和PizzaStore是组合的关系, PizzaStore使用Factory创建对象.
工厂方法模式: 对工厂类进行扩展.定义一个创建对象的接口(工厂方法).子类决定具体实例化的对象.
              创建者和产品类  都有自己的继承树.
              创建者的实现类: 实现不同产品的创建.方法内部关联产品类的子类.
              产品类的实现类: 定义不同类型的产品.
        使用:选择使用那个子类,决定了实际创建的产品是什么.
             :每个工厂类,自行负责创建行为.
             :可以使用参数化工厂方法,  或者无参构造方法
             :通常工厂类只产生一种对象
             :是一个框架,有自己的继承体系和扩展性
抽象工厂模式: