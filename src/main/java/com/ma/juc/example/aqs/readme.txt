
AQS  - - - - 抽象的队列式的同步器，是 JUC 的核心(AbstractQueuedSynchronizer)
AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，
如常用的 ReentrantLock/Semaphore/CountDownLatch。
AQS  - - - - AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，

它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列
（多线程争用资源被阻塞时会进入此队列）
volatile int  state 获取锁的线程数
    state 的访问方式有三种:
        getState()
        setState()
        compareAndSetState()
    AQS 定义两种资源共享方式
      Exclusive 独占资源-ReentrantLock
          Exclusive（独占，只有一个线程能执行，如 ReentrantLock）
      Share 共享资源-Semaphore/CountDownLatch
          Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
同步器的实现是 ABS 核心（state 资源状态计数）
  独占锁的实现
      同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。
      A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。
      此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，
      其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），
      这就是可重入的概念。
      但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。
  共享锁的实现
      以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与
      线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state
      会 CAS 减 1。
      等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，
      然后主调用线程就会从 await()函数返回，继续后余动作。
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
============================================================================
线程安全的方案：保证线程安全无非就三种方式
1.悲观锁同步，多线程挨个访问共享数据；
2.乐观锁控制+重试机制确保在更新数据时预期值和实际值一致，不一致则执行重试；
3.无锁方式，有些场景比较适合采用无锁方案，每个线程持有一份数据副本，互不干涉

一般情况下，只要synchronized可以满足，就用synchronized。Lock需要手动释放锁，
适合在synchronized不能满足的情况下使用，比如需要等待超时功能等

通过语义我们可以看出即使是在没有多线程竞争的情况下，同步互斥方式依然会有锁控制消耗，
是一种悲观的锁策略，我们称为悲观锁。
而实际应用中，同步块中的操作可能只需要很短暂的时间就可以执行完成，相对的就很少存在线程竞争的情况，
这种情况下使用悲观锁就难免存在过多的资源浪费。
=======================================================
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人
会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。
java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，
才会转换为悲观锁，如 RetreenLock。

